---
title: 从源码中学会思维和技巧
date: 2021-02-03
categories:
 - front
---

## 技巧分析

- 所有源码都会有一堆**健壮性**处理
- 利用 defineProperty 控制属性不可被更改
- 模块支持检测

**健壮性**

代码出了问题的时候，能够尽量的减少问题的影响。

1. BUG的定位速度
2. 出现错误的时候不至于让整个程序崩溃。

我们来看一个例子：

```js
function add(a, b) {
    return a + b;
}
add(1, 2)
```

那这个方法看起来是没有问题的，但是我们并没有考虑到健壮性问题，如果此时我们将传入的参数该为一个：

```js
const _result = add(1) // => NaN
```

这样的话就会得到 NaN，关键它还不会报错。假如我们是要将这个得到的结果发给后端，而后端接受的类型是一个数字，那么后端往往就会报给我们一个400错误，这是一个 Bad Request：

```js
axios.get(_result)
```

所以在一些源码里面，开头一般都是一大堆 if else 的判断，来做代码的健壮性，避免一些低级错误的出现。

所以上面的代码我们可以这样来写：

```js
function add(a, b) {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b;
    } else {
        throw new Error('a or b is not a number')
    }
}
```

那么我们又是如何保证代码出现错误的时候，不至于让整个程序崩溃呢？

最直接粗暴的解决办法就是 `try...catch...`，比如一段代码的错误不是我们能控制的，它发生错误可能需要发一些别的请求过来等等：

```js
try {
	// 容易发生错误    
} catch(e) {
    // 发生错误后将其放入错误日志，而不是抛出
}
```

但是我们说不是将所有的代码都用 `try...catch` 包裹起来，而是说一些不受人为控制的代码。

## 利用 defineProperty 控制属性不可被更改

 第一个就是变量的权限问题，在定义变量的时候，思考这个变量可不可以被更改，可不可以被读取，是私有的，还是局部的。

比如 vue 中的 router：

```js
this.$router = {}
```

这句代码虽然是一个赋值语句，而且在页面中也不会报错，但是它是不起作用的。

那为什么这块被设计成不可被更改的呢？

router 是一个路由对象，如果我们对路由对象做一些赋值修改，比如赋值为一个空对象，那么后续的路由跳转就会失效，导致页面不能跳转，项目也会因此而运行不起来，而且由于它不会报错，也很难会定位到问题所在。所以在设计之初，router 就被设计为一个不可被更改的对象，vuex 也是如此。

那 router 是怎么实现不会被更改的呢？

```js
// 首先有一个 router 对象
const router = {}

// 其次，使用 defineProperty 方法来定义原型上的 $router
Object.defineProperty(Vue.prototype, '$router', {
    get: function() {
        return router
    }
})
```

当我们使用 defineProperty 方法给一个对象定义属性的时候，如果里面只定义了 get  方法而没有定义 set 方法的话，那这个对象是永远不可以被修改的。